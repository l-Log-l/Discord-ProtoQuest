/*
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
 â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–„â–„ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•    â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â–€â–€â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   
                                                                                       
                        Discord Quest Auto-Completer v2.0
*/

delete window.$;
let wpRequire = webpackChunkdiscord_app.push([[Symbol()], {}, r => r]);
webpackChunkdiscord_app.pop();

let ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getStreamerActiveStreamMetadata).exports.Z;
let RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getRunningGames).exports.ZP;
let QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getQuest).exports.Z;
let ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getAllThreadsForParent).exports.Z;
let GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getSFWDefaultChannel).exports.ZP;
let FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.flushWaitQueue).exports.Z;
let api = Object.values(wpRequire.c).find(x => x?.exports?.tn?.get).exports.tn;
let LocaleStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getLocale).exports.Z;

let isApp = typeof DiscordNative !== "undefined";
let timerInterval = null;
let lastProgress = 0;
let lastUpdateTime = Date.now();
let isRunning = false;
let waitingMode = true;
let checkInterval = null;

// Language detection and translations
const translations = {
	en: {
		title: "PROTOQUEST - Discord Quest Completer",
		quest: "Quest",
		progress: "Progress",
		remaining: "Remaining",
		completed: "Quest completed!",
		noQuests: "No uncompleted quests found!",
		waitingMode: "Waiting mode - checking for new quests...",
		waitingForQuests: "Waiting for quests to appear...",
		nextCheck: "Next check in",
		seconds: "sec",
		minutes: "min",
		hours: "h",
		playingVideo: "Playing video for",
		gameActivated: "Game activated. Waiting for completion...",
		streamActivated: "Stream activated. Waiting for completion...",
		executingQuest: "Executing quest",
		browserError: "This no longer works in browser for non-video quests. Use the Discord desktop app to complete the",
		questWord: "quest",
		queueStatus: "Queue",
		processing: "Processing",
		pending: "Pending",
		foundNewQuest: "Found new quest",
		startingQuest: "Starting quest",
		allQuestsCompleted: "All quests completed!",
		enteringWaitMode: "Entering wait mode..."
	},
	ru: {
		title: "PROTOQUEST - ÐÐ²Ñ‚Ð¾-Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ ÐºÐ²ÐµÑÑ‚Ð¾Ð² Discord",
		quest: "Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ",
		progress: "ÐŸÑ€Ð¾Ð³Ñ€ÐµÑÑ",
		remaining: "ÐžÑÑ‚Ð°Ð»Ð¾ÑÑŒ",
		completed: "Ð—Ð°Ð´Ð°Ð½Ð¸Ðµ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¾!",
		noQuests: "ÐÐµÑ‚ Ð½ÐµÐ²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°Ð´Ð°Ð½Ð¸Ð¹!",
		waitingMode: "Ð ÐµÐ¶Ð¸Ð¼ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ - Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð½Ð¾Ð²Ñ‹Ñ… Ð·Ð°Ð´Ð°Ð½Ð¸Ð¹...",
		waitingForQuests: "ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¿Ð¾ÑÐ²Ð»ÐµÐ½Ð¸Ñ Ð·Ð°Ð´Ð°Ð½Ð¸Ð¹...",
		nextCheck: "Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ‡ÐµÑ€ÐµÐ·",
		seconds: "ÑÐµÐº",
		minutes: "Ð¼",
		hours: "Ñ‡",
		playingVideo: "Ð’Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ðµ Ð²Ð¸Ð´ÐµÐ¾ Ð´Ð»Ñ",
		gameActivated: "Ð˜Ð³Ñ€Ð° Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°. ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ...",
		streamActivated: "Ð¢Ñ€Ð°Ð½ÑÐ»ÑÑ†Ð¸Ñ Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°. ÐžÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ...",
		executingQuest: "Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ",
		browserError: "Ð­Ñ‚Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð² Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ Ð´Ð»Ñ Ð½Ðµ-Ð²Ð¸Ð´ÐµÐ¾ ÐºÐ²ÐµÑÑ‚Ð¾Ð². Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ Ð´ÐµÑÐºÑ‚Ð¾Ð¿Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Discord Ð´Ð»Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ ÐºÐ²ÐµÑÑ‚Ð°",
		questWord: "",
		queueStatus: "ÐžÑ‡ÐµÑ€ÐµÐ´ÑŒ",
		processing: "Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ",
		pending: "ÐžÐ¶Ð¸Ð´Ð°ÐµÑ‚",
		foundNewQuest: "ÐÐ°Ð¹Ð´ÐµÐ½Ð¾ Ð½Ð¾Ð²Ð¾Ðµ Ð·Ð°Ð´Ð°Ð½Ð¸Ðµ",
		startingQuest: "ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð·Ð°Ð´Ð°Ð½Ð¸Ðµ",
		allQuestsCompleted: "Ð’ÑÐµ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ñ‹!",
		enteringWaitMode: "ÐŸÐµÑ€ÐµÑ…Ð¾Ð´ Ð² Ñ€ÐµÐ¶Ð¸Ð¼ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ..."
	}
};

function getClientLanguage() {
	try {
		const locale = LocaleStore.getLocale();
		return locale && locale.startsWith('ru') ? 'ru' : 'en';
	} catch {
		return 'en';
	}
}

let currentLang = getClientLanguage();
let t = translations[currentLang];

function formatTime(seconds) {
	const hours = Math.floor(seconds / 3600);
	const minutes = Math.floor((seconds % 3600) / 60);
	const secs = seconds % 60;
	if (hours > 0) {
		return `${hours}${t.hours} ${minutes}${t.minutes} ${secs}${t.seconds}`;
	}
	return `${minutes}${t.minutes} ${secs}${t.seconds}`;
}

function createProgressBar(current, total) {
	const barLength = 30;
	const filledLength = Math.round((current / total) * barLength);
	const emptyLength = barLength - filledLength;
	
	const filled = 'â–ˆ'.repeat(filledLength);
	const empty = 'â–‘'.repeat(emptyLength);
	
	return `[${filled}${empty}]`;
}

const ASCII_LOGO = `
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
 â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–„â–„ â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
 â•šâ•â•     â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•    â•šâ•â•    â•šâ•â•â•â•â•â•  â•šâ•â•â–€â–€â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•   â•šâ•â•   
`;

function displayLogo() {
	console.log(`%c${ASCII_LOGO}`, 'color: #5865F2; font-weight: bold;');
	console.log(`%c                        ${t.title}`, 'color: #5865F2; font-size: 12px;');
	console.log('');
}

function getAvailableQuests() {
	return [...QuestsStore.quests.values()].filter(x => 
		x.id !== "1412491570820812933" && 
		x.userStatus?.enrolledAt && 
		!x.userStatus?.completedAt && 
		new Date(x.config.expiresAt).getTime() > Date.now()
	);
}

function displayQueueStatus(quests, currentIndex) {
	console.clear();
	displayLogo();
	
	console.log(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
	console.log(`â•‘  ðŸ“‹ ${t.queueStatus}: ${quests.length} ${t.quest.toLowerCase()}(s)                                    `);
	console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
	
	quests.forEach((quest, index) => {
		const questName = quest.config.messages.questName;
		const status = index < currentIndex ? 'âœ…' : (index === currentIndex ? 'ðŸ”„' : 'â³');
		const statusText = index < currentIndex ? t.completed : (index === currentIndex ? t.processing : t.pending);
		console.log(`â•‘  ${status} ${index + 1}. ${questName.substring(0, 40).padEnd(40)} [${statusText}]`);
	});
	
	console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
	console.log('');
}

function displayProgress(questName, progress, total, isWaiting = false) {
	const percentage = Math.floor((progress / total) * 100);
	const remainingSeconds = Math.max(0, total - progress);
	const progressBar = createProgressBar(Math.min(progress, total), total);
	
	console.clear();
	displayLogo();
	
	if (isWaiting) {
		console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â³ ${t.waitingMode}                         
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ${t.waitingForQuests}
   ${t.nextCheck}: 30 ${t.seconds}
		`);
	} else {
		console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸ“‹ ${t.quest.toUpperCase()}                                      
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“Œ ${t.quest}: ${questName}

${progressBar} ${percentage}%

â±ï¸  ${t.progress}: ${Math.min(progress, total)}/${total} ${t.seconds}
â° ${t.remaining}: ${formatTime(remainingSeconds)}
		`);
	}
}

function displayCompleted(questName, total) {
	console.clear();
	displayLogo();
	
	console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ðŸ“‹ ${t.quest.toUpperCase()}                                      
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“Œ ${t.quest}: ${questName}

[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%

â±ï¸  ${t.progress}: ${total}/${total} ${t.seconds}
âœ… ${t.completed}
	`);
}

function displayWaitingMode(nextCheckIn) {
	console.clear();
	displayLogo();
	
	console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â³ ${t.waitingMode}                         
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ${t.waitingForQuests}
   ${t.nextCheck}: ${nextCheckIn} ${t.seconds}
	`);
}

function startRealTimeTimer(secondsNeeded, questName) {
	if (timerInterval) clearInterval(timerInterval);
	
	timerInterval = setInterval(() => {
		const elapsedSinceUpdate = Math.floor((Date.now() - lastUpdateTime) / 1000);
		const estimatedProgress = lastProgress + elapsedSinceUpdate;
		displayProgress(questName, Math.min(estimatedProgress, secondsNeeded), secondsNeeded);
	}, 1000);
}

function updateProgress(progress, secondsNeeded, questName) {
	lastProgress = progress;
	lastUpdateTime = Date.now();
	startRealTimeTimer(secondsNeeded, questName);
}

async function executeQuest(quest) {
	return new Promise(async (resolve) => {
		const pid = Math.floor(Math.random() * 30000) + 1000;
		
		const applicationId = quest.config.application.id;
		const applicationName = quest.config.application.name;
		const questName = quest.config.messages.questName;
		const taskConfig = quest.config.taskConfig ?? quest.config.taskConfigV2;
		const taskName = ["WATCH_VIDEO", "PLAY_ON_DESKTOP", "STREAM_ON_DESKTOP", "PLAY_ACTIVITY", "WATCH_VIDEO_ON_MOBILE"].find(x => taskConfig.tasks[x] != null);
		const secondsNeeded = taskConfig.tasks[taskName].target;
		let secondsDone = quest.userStatus?.progress?.[taskName]?.value ?? 0;

		if (taskName === "WATCH_VIDEO" || taskName === "WATCH_VIDEO_ON_MOBILE") {
			const maxFuture = 10, speed = 7, interval = 1;
			const enrolledAt = new Date(quest.userStatus.enrolledAt).getTime();
			let completed = false;
			
			console.log(`â–¶ï¸  ${t.playingVideo} ${questName}...`);
			updateProgress(secondsDone, secondsNeeded, questName);
			
			while (true) {
				const maxAllowed = Math.floor((Date.now() - enrolledAt) / 1000) + maxFuture;
				const diff = maxAllowed - secondsDone;
				const timestamp = secondsDone + speed;
				if (diff >= speed) {
					const res = await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: Math.min(secondsNeeded, timestamp + Math.random())}});
					completed = res.body.completed_at != null;
					secondsDone = Math.min(secondsNeeded, timestamp);
					
					updateProgress(secondsDone, secondsNeeded, questName);
				}
				
				if (timestamp >= secondsNeeded) {
					break;
				}
				await new Promise(r => setTimeout(r, interval * 1000));
			}
			if (!completed) {
				await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: secondsNeeded}});
			}
			if (timerInterval) clearInterval(timerInterval);
			displayCompleted(questName, secondsNeeded);
			resolve();
			
		} else if (taskName === "PLAY_ON_DESKTOP") {
			if (!isApp) {
				console.log(`âŒ ${t.browserError} ${questName} ${t.questWord}!`);
				resolve();
				return;
			}
			
			const res = await api.get({url: `/applications/public?application_ids=${applicationId}`});
			const appData = res.body[0];
			const exeName = appData.executables.find(x => x.os === "win32").name.replace(">", "");
			
			const fakeGame = {
				cmdLine: `C:\\Program Files\\${appData.name}\\${exeName}`,
				exeName,
				exePath: `c:/program files/${appData.name.toLowerCase()}/${exeName}`,
				hidden: false,
				isLauncher: false,
				id: applicationId,
				name: appData.name,
				pid: pid,
				pidPath: [pid],
				processName: appData.name,
				start: Date.now(),
			};
			const realGames = RunningGameStore.getRunningGames();
			const fakeGames = [fakeGame];
			const realGetRunningGames = RunningGameStore.getRunningGames;
			const realGetGameForPID = RunningGameStore.getGameForPID;
			RunningGameStore.getRunningGames = () => fakeGames;
			RunningGameStore.getGameForPID = (pid) => fakeGames.find(x => x.pid === pid);
			FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: realGames, added: [fakeGame], games: fakeGames});
			
			console.log(`ðŸŽ® ${applicationName} ${t.gameActivated}`);
			updateProgress(secondsDone, secondsNeeded, questName);
			
			let fn = data => {
				let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.PLAY_ON_DESKTOP.value);
				updateProgress(progress, secondsNeeded, questName);
				
				if (progress >= secondsNeeded) {
					if (timerInterval) clearInterval(timerInterval);
					displayCompleted(questName, secondsNeeded);
					
					RunningGameStore.getRunningGames = realGetRunningGames;
					RunningGameStore.getGameForPID = realGetGameForPID;
					FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: [fakeGame], added: [], games: []});
					FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
					resolve();
				}
			};
			FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
			
		} else if (taskName === "STREAM_ON_DESKTOP") {
			if (!isApp) {
				console.log(`âŒ ${t.browserError} ${questName} ${t.questWord}!`);
				resolve();
				return;
			}
			
			let realFunc = ApplicationStreamingStore.getStreamerActiveStreamMetadata;
			ApplicationStreamingStore.getStreamerActiveStreamMetadata = () => ({
				id: applicationId,
				pid,
				sourceName: null
			});
			
			console.log(`ðŸ“¡ ${applicationName} ${t.streamActivated}`);
			updateProgress(secondsDone, secondsNeeded, questName);
			
			let fn = data => {
				let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.STREAM_ON_DESKTOP.value);
				updateProgress(progress, secondsNeeded, questName);
				
				if (progress >= secondsNeeded) {
					if (timerInterval) clearInterval(timerInterval);
					displayCompleted(questName, secondsNeeded);
					
					ApplicationStreamingStore.getStreamerActiveStreamMetadata = realFunc;
					FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
					resolve();
				}
			};
			FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn);
			
		} else if (taskName === "PLAY_ACTIVITY") {
			const channelId = ChannelStore.getSortedPrivateChannels()[0]?.id ?? Object.values(GuildChannelStore.getAllGuilds()).find(x => x != null && x.VOCAL.length > 0).VOCAL[0].channel.id;
			const streamKey = `call:${channelId}:1`;
			
			console.log(`â–¶ï¸  ${t.executingQuest} ${questName}...`);
			updateProgress(secondsDone, secondsNeeded, questName);
			
			while (true) {
				const res = await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: false}});
				const progress = res.body.progress.PLAY_ACTIVITY.value;
				updateProgress(progress, secondsNeeded, questName);
				
				await new Promise(r => setTimeout(r, 20 * 1000));
				
				if (progress >= secondsNeeded) {
					await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: true}});
					break;
				}
			}
			
			if (timerInterval) clearInterval(timerInterval);
			displayCompleted(questName, secondsNeeded);
			resolve();
		} else {
			resolve();
		}
	});
}

async function processQuestQueue() {
	if (isRunning) return;
	isRunning = true;
	
	let quests = getAvailableQuests();
	
	if (quests.length === 0) {
		if (waitingMode) {
			startWaitingMode();
		} else {
			console.clear();
			displayLogo();
			console.log(`âŒ ${t.noQuests}`);
		}
		isRunning = false;
		return;
	}
	
	// Stop waiting mode if it was active
	if (checkInterval) {
		clearInterval(checkInterval);
		checkInterval = null;
	}
	
	displayQueueStatus(quests, 0);
	await new Promise(r => setTimeout(r, 2000));
	
	for (let i = 0; i < quests.length; i++) {
		const quest = quests[i];
		console.log(`\nðŸš€ ${t.startingQuest}: ${quest.config.messages.questName}`);
		await new Promise(r => setTimeout(r, 1000));
		
		await executeQuest(quest);
		
		// Refresh quest list after each completion
		quests = getAvailableQuests();
		
		if (i < quests.length - 1) {
			displayQueueStatus(quests, i + 1);
			await new Promise(r => setTimeout(r, 2000));
		}
	}
	
	console.log(`\nâœ… ${t.allQuestsCompleted}`);
	
	if (waitingMode) {
		console.log(`\nâ³ ${t.enteringWaitMode}`);
		await new Promise(r => setTimeout(r, 3000));
		startWaitingMode();
	}
	
	isRunning = false;
}

function startWaitingMode() {
	if (checkInterval) {
		clearInterval(checkInterval);
	}
	
	let countdown = 30;
	displayWaitingMode(countdown);
	
	const countdownInterval = setInterval(() => {
		countdown--;
		if (countdown > 0) {
			displayWaitingMode(countdown);
		}
	}, 1000);
	
	checkInterval = setInterval(() => {
		clearInterval(countdownInterval);
		
		const quests = getAvailableQuests();
		if (quests.length > 0) {
			clearInterval(checkInterval);
			checkInterval = null;
			console.log(`\nðŸŽ‰ ${t.foundNewQuest}: ${quests[0].config.messages.questName}`);
			processQuestQueue();
		} else {
			countdown = 30;
			displayWaitingMode(countdown);
			
			const newCountdownInterval = setInterval(() => {
				countdown--;
				if (countdown > 0) {
					displayWaitingMode(countdown);
				} else {
					clearInterval(newCountdownInterval);
				}
			}, 1000);
		}
	}, 30000);
}

// Initialize
console.clear();
displayLogo();
console.log(`\nðŸŒ Language: ${currentLang === 'ru' ? 'Ð ÑƒÑÑÐºÐ¸Ð¹' : 'English'}`);
console.log(`ðŸ’» Platform: ${isApp ? 'Desktop App' : 'Browser'}`);
console.log(`\nðŸš€ Starting ProtoQuest...`);

setTimeout(() => {
	processQuestQueue();
}, 1500);